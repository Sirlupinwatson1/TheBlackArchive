namespace GitRead.Net
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Runtime.CompilerServices;
    using System.Runtime.InteropServices;

    internal class PackIndexReader
    {
        private readonly string repoPath;

        internal PackIndexReader(string repoPath)
        {
            this.repoPath = repoPath;
        }

        private int BinarySearch(FileStream fileStream, byte[] hash, int startIndex, int endIndex)
        {
            byte[] buffer = new byte[20];
            int num = 0x408;
            int num2 = ((startIndex + 1) == endIndex) ? startIndex : (((startIndex + endIndex) + 1) / 2);
            fileStream.Seek((long) (num + (num2 * 20)), (SeekOrigin) SeekOrigin.Begin);
            fileStream.Read(buffer, 0, 20);
            string.Concat((IEnumerable<string>) (from x in buffer select ((byte) x).ToString("X2")));
            ComparisonResult result = this.Compare(hash, buffer);
            return ((result != ComparisonResult.Equal) ? ((startIndex != endIndex) ? ((result != ComparisonResult.Less) ? this.BinarySearch(fileStream, hash, num2 + 1, endIndex) : this.BinarySearch(fileStream, hash, startIndex, num2 - 1)) : -1) : num2);
        }

        private ComparisonResult Compare(byte[] a, byte[] b)
        {
            for (int i = 0; i < a.Length; i++)
            {
                if (a[i] < b[i])
                {
                    return ComparisonResult.Less;
                }
                if (a[i] > b[i])
                {
                    return ComparisonResult.Greater;
                }
            }
            return ComparisonResult.Equal;
        }

        private byte[] HexStringToBytes(string str)
        {
            byte[] buffer = new byte[str.Length / 2];
            for (int i = 0; i < buffer.Length; i++)
            {
                buffer[i] = Convert.ToByte(str.Substring(i * 2, 2), 0x10);
            }
            return buffer;
        }

        internal long ReadIndex(string name, string hash)
        {
            long num9;
            byte[] buffer = new byte[4];
            using (FileStream stream = File.OpenRead(Path.Combine(this.repoPath, ______________________________("b2JqZWN0cw=="), ______________________________("cGFjaw=="), name + ______________________________("LmlkeA=="))))
            {
                int num2;
                byte[] buffer2 = new byte[4];
                stream.Read(buffer2, 0, 4);
                if ((buffer2[0] != 0xff) || ((buffer2[1] != 0x74) || ((buffer2[2] != 0x4f) || (buffer2[3] != 0x63))))
                {
                    throw new Exception(______________________________("SW52YWxpZCBpbmRleCBmaWxl"));
                }
                stream.Read(buffer2, 0, 4);
                if ((buffer2[0] != 0) || ((buffer2[1] != 0) || ((buffer2[2] != 0) || (buffer2[3] != 2))))
                {
                    throw new Exception(______________________________("SW52YWxpZCBpbmRleCBmaWxlIHZlcnNpb24="));
                }
                int num = Convert.ToInt32(hash.Substring(0, 2), 0x10);
                if (num == 0)
                {
                    num2 = 0;
                }
                else
                {
                    stream.Seek((long) ((num - 1) * 4), (SeekOrigin) SeekOrigin.Current);
                    stream.Read(buffer2, 0, 4);
                    Array.Reverse(buffer2);
                    num2 = BitConverter.ToInt32(buffer2, 0);
                }
                int num4 = this.BinarySearch(stream, this.HexStringToBytes(hash), num2, this.ReadInt32(stream, -1));
                if (num4 == -1)
                {
                    num9 = -1L;
                }
                else
                {
                    long num8;
                    int pos = 0x404;
                    int num6 = this.ReadInt32(stream, pos);
                    stream.Seek((long) ((((pos + 4) + (20 * num6)) + (4 * num6)) + (4 * num4)), (SeekOrigin) SeekOrigin.Begin);
                    stream.Read(buffer, 0, 4);
                    if ((buffer[0] & 0x80) == 0)
                    {
                        Array.Reverse(buffer);
                        num8 = BitConverter.ToInt32(buffer, 0);
                    }
                    else
                    {
                        buffer[3] = (byte) (buffer[3] & 0x7f);
                        Array.Reverse(buffer);
                        int num10 = BitConverter.ToInt32(buffer, 0);
                        num8 = this.ReadInt64(stream, ((((pos + 4) + (20 * num6)) + (4 * num6)) + (4 * num6)) + (4 * num10));
                    }
                    num9 = num8;
                }
            }
            return num9;
        }

        private int ReadInt32(FileStream fileStream, int pos = -1)
        {
            byte[] buffer = new byte[4];
            if (pos != -1)
            {
                fileStream.Seek((long) pos, (SeekOrigin) SeekOrigin.Begin);
            }
            fileStream.Read(buffer, 0, 4);
            Array.Reverse(buffer);
            return BitConverter.ToInt32(buffer, 0);
        }

        private long ReadInt64(FileStream fileStream, int pos)
        {
            byte[] buffer = new byte[8];
            fileStream.Seek((long) pos, (SeekOrigin) SeekOrigin.Begin);
            fileStream.Read(buffer, 0, 8);
            Array.Reverse(buffer);
            return BitConverter.ToInt64(buffer, 0);
        }

        [Serializable, CompilerGenerated]
        private sealed class <>c
        {
            public static readonly PackIndexReader.<>c <>9 = new PackIndexReader.<>c();
            public static Func<byte, string> <>9__6_0;

            internal string <BinarySearch>b__6_0(byte x) => 
                ((byte) x).ToString("X2");
        }

        private enum ComparisonResult
        {
            Less,
            Equal,
            Greater
        }
    }
}

